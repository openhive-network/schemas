from __future__ import annotations

import ast
import logging
from pathlib import Path
import re

from schemas.operations import __all__ as all_operations

FILE_PATH = Path(__file__).parent / "representation_types.py"


def delete_existing_model_file() -> None:
    if FILE_PATH.exists():
        FILE_PATH.unlink()


def ignore_liners_and_add_automation_generation_information(code: str) -> str:
    code += "# fmt: off\n\n"
    code += """# WARNING: This code was automatically generated by a script.\n# DO NOT EDIT this file manually, as any changes may be overwritten.\n# If modifications are needed, please update the generating script instead.\n\n"""
    return code


def collect_and_write_api_imports(code: str) -> str:
    code += "from __future__ import annotations\n\n"
    code += "from typing import Literal, overload\n\n"
    code += "import msgspec\n\n"
    code += "from schemas.operation import Operation\n\n"

    for operation_name in all_operations[4:]:
        if "Legacy" not in operation_name and "Generic" not in operation_name:
            code += f"from schemas.operations.{pascal_to_snake(operation_name)} import {operation_name}\n"
    code += "\n"
    return code

def write_hf26representation_and_legacy_representation(code: str) -> str:
    code += """class HF26Representation(msgspec.Struct):
    value: Operation
    
    @property
    def type_(self) -> str:
        return self.value.get_name_with_suffix()
    
        
class LegacyRepresentation(msgspec.Struct):
    value: Operation
    
    @property
    def type_(self) -> str:
        return self.value.get_name()
    
    @overload
    def __getitem__(self, idx: Literal[0]) -> str: ...
    @overload
    def __getitem__(self, idx: Literal[1]) -> Operation: ...

    def __getitem__(self, idx: Literal[0, 1]) -> str | Operation:
        if idx == 0:
            return self.type_
        elif idx == 1:
            return self.value
        raise ValueError("Index out of bound <0; 1>")\n\n"""
    
    return code

def write_representations_classes(code: str) -> str:
    for operation_name in all_operations[4:-23]:
        if "Generic" not in operation_name:
            code += f"""class HF26Representation{operation_name}(HF26Representation, tag="{pascal_to_snake(operation_name)}"):
            value: {operation_name}\n\n\n"""

            code += f"""class LegacyRepresentation{operation_name}(LegacyRepresentation, tag="{pascal_to_snake(operation_name)[:-10]}", array_like=True):
            value: {operation_name[:-6] if "Legacy" in operation_name else operation_name}\n\n\n"""
    return code

# def extract_exported_models_from_api(api_name: str) -> list[str]:
#     init_file_path = APIS_DIRECTORY / api_name / "__init__.py"

#     if not init_file_path.exists():
#         raise FileNotFoundError(f"Missing file {init_file_path}.")

#     with init_file_path.open("r") as file:
#         file_content = file.read()

#     tree = ast.parse(file_content)

#     for node in tree.body:
#         if isinstance(node, ast.Assign):
#             for target in node.targets:
#                 if isinstance(target, ast.Name) and target.id == "__all__" and isinstance(node.value, ast.List):
#                     methods = [elt.s for elt in node.value.elts if isinstance(elt, ast.Str)]
#                     return sorted(methods)
#     raise ValueError(f"Missing __all__ in  {init_file_path}.")


# def convert_to_pascal_case(name: str) -> str:
#     return "".join(word.title() for word in name.split("_"))

def pascal_to_snake(text: str) -> str:
    # Znajduje miejsca, gdzie są wielkie litery poprzedzone małymi lub liczbami i wstawia podkreślnik
    snake = re.sub(r'(?<!^)(?=[A-Z])', '_', text)
    # Zamienia wszystkie litery na małe
    return snake.lower()

# def generate_and_write_jsonrpc_models(code: str, api_names: list[str]) -> str:
#     classes_code = ""
#     allowed_models_as_result_union = "AllowedModelsAsResultT = (\n"

#     for i, api in enumerate(api_names):
#         for j, model in enumerate(extract_exported_models_from_api(api)):
#             class_name = f"{convert_to_pascal_case(api)}{model}JSONRPCBase"
#             classes_code += f"class {class_name}(JSONRPCResult[{api}.{model}]):\n    result: {api}.{model}\n\n\n"
#             allowed_models_as_result_union += "    " + ("" if i == 0 and j == 0 else "| ") + f"{api}.{model}\n"

#     code += allowed_models_as_result_union + ")"
#     code += """

# ExpectResultT = TypeVar("ExpectResultT", bound=AllowedModelsAsResultT)


# class JSONRPCResult(JSONRPCBase, Generic[ExpectResultT]):
#     result: ExpectResultT


# """
#     code += classes_code
#     return code


# def generate_get_jsonrpc_response_types_name_function(code: str) -> str:
#     function = """def get_jsonrpc_response_types_name(expected_model: type[ExpectResultT], endpoint: str) -> type:
#     def convert_to_pascal_case(name: str) -> str:
#         return "".join(word.title() for word in name.split("_"))

#     api_name, class_name = endpoint.split(sep=".")
#     if "EmptyResponse" in str(expected_model):
#         jsonrpc_model_name = "BeekeeperApiEmptyResponseJSONRPCBase"
#     else:
#         jsonrpc_model_name = f"{convert_to_pascal_case(api_name)}{convert_to_pascal_case(class_name)}JSONRPCBase"

#     jsonrpc_model = globals().get(jsonrpc_model_name)
#     assert jsonrpc_model is not None, f"Missing model for: {endpoint}"
#     return cast(type, jsonrpc_model)\n"""
#     code += function
#     return code


def generate_json_rpc_models_content() -> str:
    code = ""
    code = ignore_liners_and_add_automation_generation_information(code)
    code = collect_and_write_api_imports(code)
    code = write_hf26representation_and_legacy_representation(code)
    code = write_representations_classes(code)
    return code


def write_generated_models_to_file(code: str) -> None:
    with FILE_PATH.open("w") as file:
        file.write(code)


if __name__ == "__main__":
    delete_existing_model_file()
    code = generate_json_rpc_models_content()
    write_generated_models_to_file(code)
    logging.info("jsonrpc_models file overwrited")
