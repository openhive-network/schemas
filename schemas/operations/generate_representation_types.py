from __future__ import annotations

import logging
import re
from pathlib import Path
from typing import Final

from schemas.operations import __all__ as all_operations

FILE_PATH: Final[Path] = Path(__file__).parent / "representation_types.py"


def delete_existing_model_file() -> None:
    if FILE_PATH.exists():
        FILE_PATH.unlink()


def ignore_liners_and_add_automation_generation_information(code: str) -> str:
    code += "# fmt: off\n\n"
    code += """# WARNING: This code was automatically generated by a script.\n# DO NOT EDIT this file manually, as any changes may be overwritten.\n# If modifications are needed, please update the generating script instead.\n\n"""
    return code


def collect_and_write_api_imports(code: str) -> str:
    code += "from __future__ import annotations\n\n"
    code += "from typing import Any, Literal, overload\n\n"
    code += "from schemas._preconfigured_base_model import DictStrAny, PreconfiguredBaseModel\n"
    code += "from schemas.operation import OperationBase\n"

    for operation_name in all_operations[7:]:
        if "Legacy" not in operation_name and "Generic" not in operation_name:
            extra_import = ", WitnessUpdateOperationLegacy" if "WitnessUpdateOperation" in operation_name else ""
            code += f"from schemas.operations.{pascal_to_snake(operation_name)} import {operation_name}{extra_import}\n"
    code += "\n\n"
    return code


def write_hf26representation_and_legacy_representation(code: str) -> str:
    code += """class HF26Representation(PreconfiguredBaseModel):
    value: OperationBase

    def shallow_dict(self) -> dict[str, Any]:
        return {"type":self.type_, "value": self.value}

    def dict(self, *, exclude: set[str] | None = None, exclude_none: bool = False, exclude_defaults: bool = False) -> DictStrAny:
            result = super().dict(exclude=exclude,exclude_none=exclude_none, exclude_defaults=exclude_defaults)
            result["type"] = self.type_
            return result

    @property
    def type_(self) -> str:
        return self.value.get_name_with_suffix()

    @overload
    def __getitem__(self, idx: Literal[0]) -> str: ...
    @overload
    def __getitem__(self, idx: Literal[1]) -> OperationBase: ...
    @overload
    def __getitem__(self, idx: str) -> Any: ...

    def __getitem__(self, idx: Literal[0, 1] | str) -> str | OperationBase | Any:
        if idx == 0:
            return self.type_
        if idx == 1:
            return self.value
        return super().__getitem__(idx)


class LegacyRepresentation(PreconfiguredBaseModel):
    value: OperationBase

    @property
    def type_(self) -> str:
        return self.value.get_name()

    @overload  # type: ignore [override]
    def __getitem__(self, idx: Literal[0]) -> str: ...
    @overload
    def __getitem__(self, idx: Literal[1]) -> OperationBase: ...

    def __getitem__(self, idx: Literal[0, 1]) -> str | OperationBase:
        if idx == 0:
            return self.type_
        if idx == 1:
            return self.value
        raise ValueError("Index out of bound <0; 1>")\n\n"""

    return code


def write_representations_classes(code: str) -> str:
    for operation_name in all_operations[7:]:
        if "Generic" not in operation_name:
            code += f"""class HF26Representation{operation_name}(HF26Representation, tag={operation_name}.get_name_with_suffix()):
            value: {operation_name}\n\n\n"""

            code += f"""class LegacyRepresentation{operation_name}(LegacyRepresentation, tag={operation_name}.get_name(), array_like=True):
            value: {operation_name if "WitnessUpdateOperation" not in operation_name else "WitnessUpdateOperationLegacy"}\n\n\n"""
    return code


def pascal_to_snake(text: str) -> str:
    snake = re.sub(r"(?<!^)(?=[A-Z])", "_", text)
    return snake.lower()


def generate_json_rpc_models_content() -> str:
    code = ""
    code = ignore_liners_and_add_automation_generation_information(code)
    code = collect_and_write_api_imports(code)
    code = write_hf26representation_and_legacy_representation(code)
    return write_representations_classes(code)


def write_generated_models_to_file(code: str) -> None:
    with FILE_PATH.open("w") as file:
        file.write(code)


if __name__ == "__main__":
    delete_existing_model_file()
    code = generate_json_rpc_models_content()
    write_generated_models_to_file(code)
    logging.info("jsonrpc_models file overwrited")
