from __future__ import annotations

import logging
import re
from pathlib import Path

from schemas.operations.virtual import __all__ as all_operations

FILE_PATH = Path(__file__).parent / "representation_types.py"


def delete_existing_model_file() -> None:
    if FILE_PATH.exists():
        FILE_PATH.unlink()


def ignore_liners_and_add_automation_generation_information(code: str) -> str:
    code += "# fmt: off\n\n"
    code += """# WARNING: This code was automatically generated by a script.\n# DO NOT EDIT this file manually, as any changes may be overwritten.\n# If modifications are needed, please update the generating script instead.\n\n"""
    return code


def collect_and_write_api_imports(code: str) -> str:
    code += "from __future__ import annotations\n\n"
    code += "from typing import Literal, overload\n\n"
    code += "import msgspec\n\n"
    code += "from schemas.operation import Operation\n\n"

    for operation_name in all_operations[2:]:
        if "Legacy" not in operation_name and "Generic" not in operation_name:
            if "ShutDown" not in operation_name:
                code += f"from schemas.operations.virtual.{pascal_to_snake(operation_name)} import {operation_name}\n"
            else:
                code += "from schemas.operations.virtual.shutdown_witness_operation import ShutDownWitnessOperation\n"
    code += "\n"
    return code


def write_hf26representation_and_legacy_representation(code: str) -> str:
    code += """class HF26Representation(msgspec.Struct):
    value: Operation

    @property
    def type_(self) -> str:
        return self.value.get_name_with_suffix()


class LegacyRepresentation(msgspec.Struct):
    value: Operation

    @property
    def type_(self) -> str:
        return self.value.get_name()

    @overload
    def __getitem__(self, idx: Literal[0]) -> str: ...
    @overload
    def __getitem__(self, idx: Literal[1]) -> Operation: ...

    def __getitem__(self, idx: Literal[0, 1]) -> str | Operation:
        if idx == 0:
            return self.type_
        if idx == 1:
            return self.value
        raise ValueError("Index out of bound <0; 1>")\n\n"""

    return code


def write_representations_classes(code: str) -> str:
    for operation_name in all_operations[2:-32]:
        if "Generic" not in operation_name:
            code += f"""class HF26Representation{operation_name}(HF26Representation, tag={operation_name}.get_name_with_suffix()):
            value: {operation_name}\n\n\n"""

            code += f"""class LegacyRepresentation{operation_name}(LegacyRepresentation, tag={operation_name}.get_name(), array_like=True):
            value: {operation_name[:-6] if "Legacy" in operation_name else operation_name}\n\n\n"""
    return code


# def extract_exported_models_from_api(api_name: str) -> list[str]:

#     if not init_file_path.exists():

#     with init_file_path.open("r") as file:


#     for node in tree.body:
#         if isinstance(node, ast.Assign):
#             for target in node.targets:
#                 if isinstance(target, ast.Name) and target.id == "__all__" and isinstance(node.value, ast.List):


# def convert_to_pascal_case(name: str) -> str:


def pascal_to_snake(text: str) -> str:
    # Znajduje miejsca, gdzie są wielkie litery poprzedzone małymi lub liczbami i wstawia podkreślnik
    snake = re.sub(r"(?<!^)(?=[A-Z])", "_", text)
    # Zamienia wszystkie litery na małe
    return snake.lower()


# def generate_and_write_jsonrpc_models(code: str, api_names: list[str]) -> str:

#     for i, api in enumerate(api_names):
#         for j, model in enumerate(extract_exported_models_from_api(api)):

#     code += """


# class JSONRPCResult(JSONRPCBase, Generic[ExpectResultT]):


# """


# def generate_get_jsonrpc_response_types_name_function(code: str) -> str:
#     function = """def get_jsonrpc_response_types_name(expected_model: type[ExpectResultT], endpoint: str) -> type:
#     def convert_to_pascal_case(name: str) -> str:

#     if "EmptyResponse" in str(expected_model):

#     return cast(type, jsonrpc_model)\n"""


def generate_json_rpc_models_content() -> str:
    code = ""
    code = ignore_liners_and_add_automation_generation_information(code)
    code = collect_and_write_api_imports(code)
    code = write_hf26representation_and_legacy_representation(code)
    return write_representations_classes(code)


def write_generated_models_to_file(code: str) -> None:
    with FILE_PATH.open("w") as file:
        file.write(code)


if __name__ == "__main__":
    delete_existing_model_file()
    code = generate_json_rpc_models_content()
    write_generated_models_to_file(code)
    logging.info("jsonrpc_models file overwrited")
